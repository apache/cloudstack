#!/bin/bash
### BEGIN INIT INFO
# Provides:          cloud-early-init
# Required-Start:    mountkernfs $local_fs
# Required-Stop:     $local_fs
# Should-Start:      
# Should-Stop:       
# Default-Start:     S
# Default-Stop:      0 6
# Short-Description: configure according to cmdline
### END INIT INFO
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin"

[ -f /usr/sbin/hv_kvp_daemon ] && /usr/sbin/hv_kvp_daemon

# Fix haproxy directory issue
mkdir -p /var/lib/haproxy

# Clear boot up flag, it would be created by rc.local after boot up done
rm -f /var/cache/cloud/boot_up_done

[ -x /sbin/ifup ] || exit 0

. /lib/lsb/init-functions

log_it() {
  echo "$(date) $@" >> /var/log/cloud.log
  log_action_msg "$@"
}

hypervisor() {
  [ -d /proc/xen ] && mount -t xenfs none /proc/xen
  [ -d /proc/xen ] && echo "xen-domU" && return 0

  local try=$([ -x /usr/sbin/virt-what ] && virt-what | tail -1)
  [ "$try" != "" ] && echo $try && return 0

  vmware-checkvm &> /dev/null && echo "vmware" && return 0

  grep -q QEMU /proc/cpuinfo  && echo "kvm" && return 0
  grep -q QEMU /var/log/messages && echo "kvm" && return 0

  echo "unknown" && return 1

}

get_boot_params() {
  local EXTRA_MOUNT=/media/extra
  local hyp=$(hypervisor)
  [ $? -ne 0 ] && log_it "Failed to detect hypervisor type, bailing out of early init" && exit 10

  case $hyp in
     xen-domU|xen-hvm)
          cat /proc/cmdline > /var/cache/cloud/cmdline
          sed -i "s/%/ /g" /var/cache/cloud/cmdline
          ;;
     kvm)
          VPORT=$(find /dev/virtio-ports -type l -name '*.vport' 2>/dev/null|head -1)

          if [ -z "$VPORT" ]; then
            log_it "No suitable VirtIO port was found in /dev/virtio-ports" && exit 2
          fi

          if [ ! -e "$VPORT" ]; then
            log_it "${VPORT} not loaded, perhaps guest kernel is too old." && exit 2
          fi

	      local factor=2
	      local progress=1
		  for i in {1..5}
		  do
	        while read line; do
	          if [[ $line == cmdline:* ]]; then
	            cmd=${line//cmdline:/}
                echo $cmd > /var/cache/cloud/cmdline
	          elif [[ $line == pubkey:* ]]; then
	            pubkey=${line//pubkey:/}
	            echo $pubkey > /var/cache/cloud/authorized_keys
	            echo $pubkey > /root/.ssh/authorized_keys
              fi
	        done < $VPORT
	        # In case of reboot we do not send the boot args again.
	        # So, no need to wait for them, as the boot args are already set at startup
	        if [ -s /var/cache/cloud/cmdline  ]
	        then
              log_it "Found a non empty cmdline file. Will now exit the loop and proceed with configuration."
              break;
            fi
            sleep ${progress}s
            progress=$[ progress * factor ]
		  done
          chmod go-rwx /root/.ssh/authorized_keys
          ;;
     vmware)
          vmtoolsd --cmd 'machine.id.get' > /var/cache/cloud/cmdline 
          ;;
     virtualpc|hyperv)
          # Hyper-V is recognized as virtualpc hypervisor type. Boot args are passed using KVP Daemon
          #waiting for the hv_kvp_daemon to start up
          #sleep  need to fix the race condition of hv_kvp_daemon and cloud-early-config
          sleep 5
          cp -f /var/opt/hyperv/.kvp_pool_0 /var/cache/cloud/cmdline
          cat /dev/null > /var/opt/hyperv/.kvp_pool_0
          ;;
     virtualbox)
          # Virtualbox is used to test the virtual router
          # get the commandline from a dmistring  (yes, hacky!)
          dmidecode | grep cmdline | sed 's/^.*cmdline://' > /var/cache/cloud/cmdline
          RV=$?
          if [ $RV -ne 0 ] ; then
            log_it "Failed to get cmdline from a virtualbox dmi property"
          fi
          ;;
  esac

}

patch() {
  local PATCH_MOUNT=/media/cdrom
  local patchfile=$PATCH_MOUNT/cloud-scripts.tgz
  local md5file=/var/cache/cloud/cloud-scripts-signature
  local privkey=$PATCH_MOUNT/authorized_keys
  local shouldpatch=false
  local cdrom_dev=
  mkdir -p $PATCH_MOUNT


  if [ -e /dev/xvdd ]; then
       cdrom_dev=/dev/xvdd
  elif [ -e /dev/cdrom ]; then
       cdrom_dev=/dev/cdrom
  elif [ -e /dev/cdrom1 ]; then
       cdrom_dev=/dev/cdrom1
  elif [ -e /dev/cdrom2 ]; then
       cdrom_dev=/dev/cdrom2
  elif [ -e /dev/cdrom3 ]; then
       cdrom_dev=/dev/cdrom3
  fi
  [ -f /var/cache/cloud/authorized_keys ] && privkey=/var/cache/cloud/authorized_keys

  if [ -n "$cdrom_dev" ]; then
    mount -o ro $cdrom_dev $PATCH_MOUNT
    [ -f $privkey ] && cp -f $privkey /root/.ssh/ && chmod go-rwx /root/.ssh/authorized_keys
    local oldmd5=
    [ -f ${md5file} ] && oldmd5=$(cat ${md5file})
    local newmd5=
    [ -f ${patchfile} ] && newmd5=$(md5sum ${patchfile} | awk '{print $1}')
 
   if [ "$oldmd5" != "$newmd5" ] && [ -f ${patchfile} ] && [ "$newmd5" != "" ]
    then
      shouldpatch=true
      log_it "Patching  scripts oldmd5=$oldmd5 newmd5=$newmd5"
      tar xzf $patchfile -C /
      echo ${newmd5} > ${md5file}
    fi
    log_it "Patching  cloud service"
    hyperVisor=$(hypervisor)
    /opt/cloud/bin/patchsystemvm.sh $PATCH_MOUNT $hyperVisor
    umount $PATCH_MOUNT

# removing reboot for the moment    
#    if [ "$shouldpatch" == "true" ] 
#    then
#      log_it "Rebooting system since we patched init scripts"
#      sync
#      sleep 2
#      reboot
#    fi
  fi
  if [ -f /mnt/cmdline ]; then
    cat /mnt/cmdline > /var/cache/cloud/cmdline
  fi
  return 0
}

start() {
  # Clear /tmp for file lock
  rm -f /tmp/*.lock
  rm -f /tmp/rrouter_bumped
  local hyp=$(hypervisor)
  [ $? -ne 0 ] && log_it "Failed to detect hypervisor type, bailing out of early init" && exit 10
  log_it "Detected that we are running inside $hyp guest"
  get_boot_params
  patch
    if [ "$hyp" == "hyperv" ]; then
    # eject the systemvm.iso
     eject
  fi
  return 0
}

disable_hvc

parse_cmd_line() {
CMDLINE=$(cat /var/cache/cloud/cmdline)
TYPE="unknown"
BOOTPROTO="static"
DISABLE_RP_FILTER="false"
STORAGE_IP=""
STORAGE_NETMASK=""
STORAGE_CIDR=""
VM_PASSWORD=""

CHEF_TMP_FILE=/tmp/cmdline.json
COMMA="\t"
echo -e "{\n\"type\": \"cmdline\"," > ${CHEF_TMP_FILE}
echo -e "\n\"cmd_line\": {" >> ${CHEF_TMP_FILE}

for i in $CMDLINE
  do
    # search for foo=bar pattern and cut out foo
    KEY=$(echo $i | cut -d= -f1)
    VALUE=$(echo $i | cut -d= -f2)
    echo -en ${COMMA} >> ${CHEF_TMP_FILE}
    # Two lines so values do not accidently interpretted as escapes!!
    echo -n \"${KEY}\"': '\"${VALUE}\" >> ${CHEF_TMP_FILE}
    COMMA=",\n\t"
    case $KEY in 
      disable_rp_filter)
          DISABLE_RP_FILTER=$VALUE
          ;;
      eth0ip)
          ETH0_IP=$VALUE
          ;;
      eth1ip)
          ETH1_IP=$VALUE
          ;;
      eth2ip)
          ETH2_IP=$VALUE
          ;;
      host)
          MGMT_HOST=$VALUE
          ;;
      gateway)
          GW=$VALUE
          ;;
      ip6gateway)
          IP6GW=$VALUE
          ;;
      eth0mask)
          ETH0_MASK=$VALUE
          ;;
      eth1mask)
          ETH1_MASK=$VALUE
          ;;
      eth2mask)
          ETH2_MASK=$VALUE
          ;;
      eth0ip6)
          ETH0_IP6=$VALUE
          ;;
      eth0ip6prelen)
          ETH0_IP6_PRELEN=$VALUE
          ;;
      internaldns1)
          internalNS1=$VALUE
          ;;
      internaldns2)
          internalNS2=$VALUE
          ;;
      dns1)
          NS1=$VALUE
          ;;
      dns2)
          NS2=$VALUE
          ;;
      ip6dns1)
          IP6_NS1=$VALUE
          ;;
      ip6dns2)
          IP6_NS2=$VALUE
          ;;
      domain)
          DOMAIN=$VALUE
          ;;
      dnssearchorder)
          DNS_SEARCH_ORDER=$VALUE
          ;;
      useextdns)
        USE_EXTERNAL_DNS=$VALUE
          ;;
      mgmtcidr)
          MGMTNET=$VALUE
          ;;
      localgw)
          LOCAL_GW=$VALUE
          ;;
      template)
        TEMPLATE=$VALUE
      	;;
      sshonguest)
        SSHONGUEST=$VALUE
        ;;
      name)
	    NAME=$VALUE
	    ;;
      dhcprange)
        DHCP_RANGE=$(echo $VALUE | tr ':' ',')
      	;;
      bootproto)
        BOOTPROTO=$VALUE 
      	;;
      type)
        TYPE=$VALUE	
	    ;;
      defaultroute)
        DEFAULTROUTE=$VALUE	
	;;
      redundant_router)
        RROUTER=$VALUE
        ;;
      guestgw)
        GUEST_GW=$VALUE
        ;;
      guestbrd)
        GUEST_BRD=$VALUE
        ;;
      guestcidrsize)
        GUEST_CIDR_SIZE=$VALUE
        ;;
      router_pr)
        ROUTER_PR=$VALUE
        ;;
      extra_pubnics)
        EXTRA_PUBNICS=$VALUE
        ;;
      nic_macs)
        NIC_MACS=$VALUE
        ;;
      mtu)
        MTU=$VALUE
        ;;
      storageip)
        STORAGE_IP=$VALUE
        ;;
      storagenetmask)
        STORAGE_NETMASK=$VALUE
        ;;
      storagecidr)
        STORAGE_CIDR=$VALUE
        ;;
      vmpassword)
        VM_PASSWORD=$VALUE
        ;;
      vpccidr)
        VPCCIDR=$VALUE
        ;;
      cidrsize)
        CIDR_SIZE=$VALUE
        ;;
      advert_int)
        ADVERT_INT=$VALUE
        ;;
      ntpserverlist)
        NTP_SERVER_LIST=$VALUE
        ;;
    esac
done
echo -e "\n\t}\n}" >> ${CHEF_TMP_FILE}
if [ "$TYPE" != "unknown" ]
then
	mv ${CHEF_TMP_FILE} /var/cache/cloud/cmd_line.json
fi

[ $ETH0_IP ] && LOCAL_ADDRS=$ETH0_IP
[ $ETH0_IP6 ] && LOCAL_ADDRS=$ETH0_IP6
[ $ETH0_IP ] && [ $ETH0_IP6 ] && LOCAL_ADDRS="$ETH0_IP,$ETH0_IP6"
}

case "$1" in
start)

	log_action_begin_msg "Executing cloud-early-config"
        log_it "Executing cloud-early-config"
	if start; then
	    log_action_end_msg $?
	else
	    log_action_end_msg $?
	fi
	;;

stop)
	log_action_begin_msg "Stopping cloud-early-config"
        #Override old system's interface setting
        setup_default;
	log_action_end_msg 0
	;;

force-reload|restart)

	log_warning_msg "Running $0  is deprecated because it may not enable again some interfaces"
	log_action_begin_msg "Executing cloud-early-config"
	if start; then
	    log_action_end_msg $?
	else
	    log_action_end_msg $?
	fi
	;;

*)
	echo "Usage: /etc/init.d/cloud-early-config {start|stop}"
	exit 1
	;;
esac

exit 0
